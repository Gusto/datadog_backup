#!/usr/bin/env ruby

$:.unshift File.join(File.dirname(__FILE__), '../lib')

require 'logger'
require 'optparse'

require 'datadog_sync'
require 'dogapi'

$stdout.sync = $stderr.sync = true
unless defined?(LOGGER)
  LOGGER = Logger.new($stderr)
end
LOGGER.level = Logger::INFO

##
# Default parameters
@options = {
  action: nil,
  client: nil,
  output_dir: ENV.fetch('PWD'),
  resources: [DatadogSync::Dashboards, DatadogSync::Monitors],
  logger: LOGGER
}

def prereqs
  ARGV << '--help' if ARGV.empty?

  opts = OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename($0)} <backup|restore>"
    opts.separator ''
    opts.on_tail('-h', '--help', 'Show this message') do
      puts opts
      exit 0
    end
    opts.on('--verbose', '-v', 'verbose') do
      LOGGER.level = Logger::DEBUG
    end
    opts.on('--backup-dir PATH') do |path|
      @options[:backup_dir] = path
    end
    opts.on('--monitors-only') do
      @options[:resources] = [DatadogSync::Monitors]
    end
    opts.on('--dashboards-only') do
      @options[:resources] = [DatadogSync::Dashboards]
    end
    opts.on('--dashboards-only') do
      @options[:resources] = [DatadogSync::Dashboards]
    end
  end
  opts.parse!

  @options[:action] = ARGV.first
  if ['backup', 'restore'].include?(@options[:action])
  else
    puts opts
    exit 0
  end

  required_vars = %w[
    DATADOG_API_KEY
    DATADOG_APP_KEY
  ]
  required_vars.each do |v|
    raise "#{v} must be specified in the environment variables" unless ENV[v]
  end
end


def main
  begin
    @options[:client] = Dogapi::Client.new(
      ENV.fetch('DATADOG_API_KEY'),
      ENV.fetch('DATADOG_APP_KEY')
    )
    @options[:resources].each do |resource|
      resource.new(@options).execute!
    end

  rescue => e
    LOGGER.error "Unhandled exception #{e.class}: #{e.message}"
    e.backtrace.each do |v|
      LOGGER.debug v
    end
    raise
  end
end

prereqs
main
